pub mod user_table {
    //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.14
    use sea_orm::entity::prelude::*;
    #[sea_orm(table_name = "user_table")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        #[sea_orm(column_type = "Text", nullable)]
        pub username: Option<String>,
        pub is_active: Option<bool>,
        pub is_admin: Option<bool>,
        pub created_date: Option<DateTime>,
        pub updated_date: Option<DateTime>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Model {
        #[inline]
        fn clone(&self) -> Model {
            Model {
                id: ::core::clone::Clone::clone(&self.id),
                username: ::core::clone::Clone::clone(&self.username),
                is_active: ::core::clone::Clone::clone(&self.is_active),
                is_admin: ::core::clone::Clone::clone(&self.is_admin),
                created_date: ::core::clone::Clone::clone(&self.created_date),
                updated_date: ::core::clone::Clone::clone(&self.updated_date),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Model {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "username",
                "is_active",
                "is_admin",
                "created_date",
                "updated_date",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.username,
                &self.is_active,
                &self.is_admin,
                &self.created_date,
                &&self.updated_date,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Model", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Model {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Model {
        #[inline]
        fn eq(&self, other: &Model) -> bool {
            self.id == other.id && self.username == other.username
                && self.is_active == other.is_active && self.is_admin == other.is_admin
                && self.created_date == other.created_date
                && self.updated_date == other.updated_date
        }
    }
    /// Generated by sea-orm-macros
    pub enum Column {
        /// Generated by sea-orm-macros
        Id,
        /// Generated by sea-orm-macros
        Username,
        /// Generated by sea-orm-macros
        IsActive,
        /// Generated by sea-orm-macros
        IsAdmin,
        /// Generated by sea-orm-macros
        CreatedDate,
        /// Generated by sea-orm-macros
        UpdatedDate,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Column {}
    #[automatically_derived]
    impl ::core::clone::Clone for Column {
        #[inline]
        fn clone(&self) -> Column {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Column {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Column::Id => "Id",
                    Column::Username => "Username",
                    Column::IsActive => "IsActive",
                    Column::IsAdmin => "IsAdmin",
                    Column::CreatedDate => "CreatedDate",
                    Column::UpdatedDate => "UpdatedDate",
                },
            )
        }
    }
    ///An iterator over the variants of [Column]
    #[allow(missing_copy_implementations)]
    pub struct ColumnIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for ColumnIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ColumnIter").field("len", &self.len()).finish()
        }
    }
    impl ColumnIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Column> {
            match idx {
                0usize => ::core::option::Option::Some(Column::Id),
                1usize => ::core::option::Option::Some(Column::Username),
                2usize => ::core::option::Option::Some(Column::IsActive),
                3usize => ::core::option::Option::Some(Column::IsAdmin),
                4usize => ::core::option::Option::Some(Column::CreatedDate),
                5usize => ::core::option::Option::Some(Column::UpdatedDate),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Column {
        type Iterator = ColumnIter;
        fn iter() -> ColumnIter {
            ColumnIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for ColumnIter {
        type Item = Column;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 6usize {
                0
            } else {
                6usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 6usize {
                self.idx = 6usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                ColumnIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for ColumnIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for ColumnIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 6usize {
                self.back_idx = 6usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                ColumnIter::get(self, 6usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for ColumnIter {}
    impl Clone for ColumnIter {
        fn clone(&self) -> ColumnIter {
            ColumnIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl Column {
        fn default_as_str(&self) -> &str {
            match self {
                Self::Id => "id",
                Self::Username => "username",
                Self::IsActive => "is_active",
                Self::IsAdmin => "is_admin",
                Self::CreatedDate => "created_date",
                Self::UpdatedDate => "updated_date",
            }
        }
    }
    #[automatically_derived]
    impl std::str::FromStr for Column {
        type Err = sea_orm::ColumnFromStrErr;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "id" | "id" | "id" => Ok(Column::Id),
                "username" | "username" | "username" => Ok(Column::Username),
                "is_active" | "isActive" | "is_active" => Ok(Column::IsActive),
                "is_admin" | "isAdmin" | "is_admin" => Ok(Column::IsAdmin),
                "created_date" | "createdDate" | "created_date" => {
                    Ok(Column::CreatedDate)
                }
                "updated_date" | "updatedDate" | "updated_date" => {
                    Ok(Column::UpdatedDate)
                }
                _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for Column {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Column {
        fn as_str(&self) -> &str {
            self.default_as_str()
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::ColumnTrait for Column {
        type EntityName = Entity;
        fn def(&self) -> sea_orm::prelude::ColumnDef {
            match self {
                Self::Id => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::Username => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::Text,
                        )
                        .nullable()
                }
                Self::IsActive => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::Boolean,
                        )
                        .nullable()
                }
                Self::IsAdmin => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::Boolean,
                        )
                        .nullable()
                }
                Self::CreatedDate => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::DateTime,
                        )
                        .nullable()
                }
                Self::UpdatedDate => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::DateTime,
                        )
                        .nullable()
                }
            }
        }
        fn enum_type_name(&self) -> Option<&'static str> {
            match self {
                Self::Id => <i32 as sea_orm::sea_query::ValueType>::enum_type_name(),
                Self::Username => {
                    <String as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::IsActive => {
                    <bool as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::IsAdmin => {
                    <bool as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::CreatedDate => {
                    <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::UpdatedDate => {
                    <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                }
            }
        }
        fn select_as(
            &self,
            expr: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
            }
        }
        fn save_as(
            &self,
            val: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct Entity;
    #[automatically_derived]
    impl ::core::marker::Copy for Entity {}
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Entity {
        #[inline]
        fn default() -> Entity {
            Entity {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Entity")
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::EntityTrait for Entity {
        type Model = Model;
        type ActiveModel = ActiveModel;
        type Column = Column;
        type PrimaryKey = PrimaryKey;
        type Relation = Relation;
    }
    #[automatically_derived]
    impl sea_orm::Iden for Entity {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Entity {
        fn as_str(&self) -> &str {
            <Self as sea_orm::EntityName>::table_name(self)
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::EntityName for Entity {
        fn schema_name(&self) -> Option<&str> {
            None
        }
        fn table_name(&self) -> &str {
            "user_table"
        }
        fn comment(&self) -> Option<&str> {
            None
        }
    }
    /// Generated by sea-orm-macros
    pub enum PrimaryKey {
        /// Generated by sea-orm-macros
        Id,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrimaryKey {}
    #[automatically_derived]
    impl ::core::clone::Clone for PrimaryKey {
        #[inline]
        fn clone(&self) -> PrimaryKey {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrimaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Id")
        }
    }
    ///An iterator over the variants of [PrimaryKey]
    #[allow(missing_copy_implementations)]
    pub struct PrimaryKeyIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for PrimaryKeyIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
        }
    }
    impl PrimaryKeyIter {
        fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
            match idx {
                0usize => ::core::option::Option::Some(PrimaryKey::Id),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
        type Iterator = PrimaryKeyIter;
        fn iter() -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for PrimaryKeyIter {
        type Item = PrimaryKey;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                PrimaryKeyIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for PrimaryKeyIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for PrimaryKeyIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                PrimaryKeyIter::get(self, 1usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for PrimaryKeyIter {}
    impl Clone for PrimaryKeyIter {
        fn clone(&self) -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for PrimaryKey {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for PrimaryKey {
        fn as_str(&self) -> &str {
            match self {
                Self::Id => "id",
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
        type Column = Column;
        fn into_column(self) -> Self::Column {
            match self {
                Self::Id => Self::Column::Id,
            }
        }
        fn from_column(col: Self::Column) -> Option<Self> {
            match col {
                Self::Column::Id => Some(Self::Id),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl PrimaryKeyTrait for PrimaryKey {
        type ValueType = i32;
        fn auto_increment() -> bool {
            true
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for Model {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                            )
                            .into(),
                    )?,
                username: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Username,
                            )
                            .into(),
                    )?,
                is_active: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::IsActive,
                            )
                            .into(),
                    )?,
                is_admin: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::IsAdmin,
                            )
                            .into(),
                    )?,
                created_date: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreatedDate,
                            )
                            .into(),
                    )?,
                updated_date: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedDate,
                            )
                            .into(),
                    )?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::ModelTrait for Model {
        type Entity = Entity;
        fn get(
            &self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        ) -> sea_orm::Value {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Username => {
                    self.username.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::IsActive => {
                    self.is_active.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::IsAdmin => {
                    self.is_admin.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedDate => {
                    self.created_date.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date.clone().into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Username => {
                    self.username = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::IsActive => {
                    self.is_active = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::IsAdmin => {
                    self.is_admin = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedDate => {
                    self.created_date = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date = v.unwrap();
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct ActiveModel {
        /// Generated by sea-orm-macros
        pub id: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub username: sea_orm::ActiveValue<Option<String>>,
        /// Generated by sea-orm-macros
        pub is_active: sea_orm::ActiveValue<Option<bool>>,
        /// Generated by sea-orm-macros
        pub is_admin: sea_orm::ActiveValue<Option<bool>>,
        /// Generated by sea-orm-macros
        pub created_date: sea_orm::ActiveValue<Option<DateTime>>,
        /// Generated by sea-orm-macros
        pub updated_date: sea_orm::ActiveValue<Option<DateTime>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActiveModel {
        #[inline]
        fn clone(&self) -> ActiveModel {
            ActiveModel {
                id: ::core::clone::Clone::clone(&self.id),
                username: ::core::clone::Clone::clone(&self.username),
                is_active: ::core::clone::Clone::clone(&self.is_active),
                is_admin: ::core::clone::Clone::clone(&self.is_admin),
                created_date: ::core::clone::Clone::clone(&self.created_date),
                updated_date: ::core::clone::Clone::clone(&self.updated_date),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActiveModel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "username",
                "is_active",
                "is_admin",
                "created_date",
                "updated_date",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.username,
                &self.is_active,
                &self.is_admin,
                &self.created_date,
                &&self.updated_date,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ActiveModel",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ActiveModel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ActiveModel {
        #[inline]
        fn eq(&self, other: &ActiveModel) -> bool {
            self.id == other.id && self.username == other.username
                && self.is_active == other.is_active && self.is_admin == other.is_admin
                && self.created_date == other.created_date
                && self.updated_date == other.updated_date
        }
    }
    #[automatically_derived]
    impl std::default::Default for ActiveModel {
        fn default() -> Self {
            <Self as sea_orm::ActiveModelBehavior>::new()
        }
    }
    #[automatically_derived]
    impl std::convert::From<Model> for ActiveModel {
        fn from(m: Model) -> Self {
            Self {
                id: sea_orm::ActiveValue::Unchanged(m.id),
                username: sea_orm::ActiveValue::Unchanged(m.username),
                is_active: sea_orm::ActiveValue::Unchanged(m.is_active),
                is_admin: sea_orm::ActiveValue::Unchanged(m.is_admin),
                created_date: sea_orm::ActiveValue::Unchanged(m.created_date),
                updated_date: sea_orm::ActiveValue::Unchanged(m.updated_date),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::IntoActiveModel<ActiveModel> for Model {
        fn into_active_model(self) -> ActiveModel {
            self.into()
        }
    }
    #[automatically_derived]
    impl sea_orm::ActiveModelTrait for ActiveModel {
        type Entity = Entity;
        fn take(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.id);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.username);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.is_active);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.is_admin);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.created_date);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    let mut value = sea_orm::ActiveValue::NotSet;
                    std::mem::swap(&mut value, &mut self.updated_date);
                    value.into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::NotSet,
            }
        }
        fn get(
            &self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    self.username.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    self.is_active.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    self.is_admin.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    self.created_date.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date.clone().into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::NotSet,
            }
        }
        fn try_set(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
            v: sea_orm::Value,
        ) -> Result<(), sea_orm::DbErr> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    self.username = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    self.is_active = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    self.is_admin = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    self.created_date = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date = sea_orm::ActiveValue::set(
                        sea_orm::sea_query::ValueType::try_from(v)
                            .map_err(|e| sea_orm::DbErr::Type(e.to_string()))?,
                    );
                }
                _ => {
                    return Err(
                        sea_orm::DbErr::Type(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "This ActiveModel does not have this field: {0}",
                                        sea_orm::IdenStatic::as_str(&c),
                                    ),
                                );
                                res
                            }),
                        ),
                    );
                }
            }
            Ok(())
        }
        fn not_set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::NotSet;
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    self.username = sea_orm::ActiveValue::NotSet;
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    self.is_active = sea_orm::ActiveValue::NotSet;
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    self.is_admin = sea_orm::ActiveValue::NotSet;
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    self.created_date = sea_orm::ActiveValue::NotSet;
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date = sea_orm::ActiveValue::NotSet;
                }
                _ => {}
            }
        }
        fn is_not_set(&self, c: <Self::Entity as sea_orm::EntityTrait>::Column) -> bool {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    self.username.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    self.is_active.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    self.is_admin.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    self.created_date.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date.is_not_set()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
        fn default() -> Self {
            Self {
                id: sea_orm::ActiveValue::NotSet,
                username: sea_orm::ActiveValue::NotSet,
                is_active: sea_orm::ActiveValue::NotSet,
                is_admin: sea_orm::ActiveValue::NotSet,
                created_date: sea_orm::ActiveValue::NotSet,
                updated_date: sea_orm::ActiveValue::NotSet,
            }
        }
        fn default_values() -> Self {
            use sea_orm::value::{
                DefaultActiveValue, DefaultActiveValueNone, DefaultActiveValueNotSet,
            };
            let mut default = <Self as sea_orm::ActiveModelTrait>::default();
            default.id = (&default.id).default_value();
            default.username = (&default.username).default_value();
            default.is_active = (&default.is_active).default_value();
            default.is_admin = (&default.is_admin).default_value();
            default.created_date = (&default.created_date).default_value();
            default.updated_date = (&default.updated_date).default_value();
            default
        }
        fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.reset(),
                <Self::Entity as sea_orm::EntityTrait>::Column::Username => {
                    self.username.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsActive => {
                    self.is_active.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::IsAdmin => {
                    self.is_admin.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedDate => {
                    self.created_date.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedDate => {
                    self.updated_date.reset()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
    }
    #[automatically_derived]
    impl std::convert::TryFrom<ActiveModel> for Model {
        type Error = sea_orm::DbErr;
        fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
            if match a.id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
            }
            if match a.username {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("username".to_owned()));
            }
            if match a.is_active {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("is_active".to_owned()));
            }
            if match a.is_admin {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("is_admin".to_owned()));
            }
            if match a.created_date {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("created_date".to_owned()));
            }
            if match a.updated_date {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("updated_date".to_owned()));
            }
            Ok(Self {
                id: a.id.into_value().unwrap().unwrap(),
                username: a.username.into_value().unwrap().unwrap(),
                is_active: a.is_active.into_value().unwrap().unwrap(),
                is_admin: a.is_admin.into_value().unwrap().unwrap(),
                created_date: a.created_date.into_value().unwrap().unwrap(),
                updated_date: a.updated_date.into_value().unwrap().unwrap(),
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::TryIntoModel<Model> for ActiveModel {
        fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
            self.try_into()
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Model {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<i32>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<DateTime>>;
            let _: ::core::cmp::AssertParamIsEq<Option<DateTime>>;
        }
    }
    pub enum Relation {
        #[sea_orm(has_many = "super::money_history_table::Entity")]
        MoneyHistoryTable,
        #[sea_orm(has_many = "super::payment_history_table::Entity")]
        PaymentHistoryTable,
        #[sea_orm(has_many = "super::taking_record_table::Entity")]
        TakingRecordTable,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Relation {}
    #[automatically_derived]
    impl ::core::clone::Clone for Relation {
        #[inline]
        fn clone(&self) -> Relation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Relation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Relation::MoneyHistoryTable => "MoneyHistoryTable",
                    Relation::PaymentHistoryTable => "PaymentHistoryTable",
                    Relation::TakingRecordTable => "TakingRecordTable",
                },
            )
        }
    }
    ///An iterator over the variants of [Relation]
    #[allow(missing_copy_implementations)]
    pub struct RelationIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for RelationIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RelationIter").field("len", &self.len()).finish()
        }
    }
    impl RelationIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
            match idx {
                0usize => ::core::option::Option::Some(Relation::MoneyHistoryTable),
                1usize => ::core::option::Option::Some(Relation::PaymentHistoryTable),
                2usize => ::core::option::Option::Some(Relation::TakingRecordTable),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Relation {
        type Iterator = RelationIter;
        fn iter() -> RelationIter {
            RelationIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for RelationIter {
        type Item = Relation;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 3usize {
                0
            } else {
                3usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 3usize {
                self.idx = 3usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                RelationIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for RelationIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for RelationIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 3usize {
                self.back_idx = 3usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                RelationIter::get(self, 3usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for RelationIter {}
    impl Clone for RelationIter {
        fn clone(&self) -> RelationIter {
            RelationIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::RelationTrait for Relation {
        fn def(&self) -> sea_orm::entity::RelationDef {
            match self {
                Self::MoneyHistoryTable => {
                    Entity::has_many(super::money_history_table::Entity).into()
                }
                Self::PaymentHistoryTable => {
                    Entity::has_many(super::payment_history_table::Entity).into()
                }
                Self::TakingRecordTable => {
                    Entity::has_many(super::taking_record_table::Entity).into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("No RelationDef for Relation"),
                    );
                }
            }
        }
    }
    impl Related<super::money_history_table::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::MoneyHistoryTable.def()
        }
    }
    impl Related<super::payment_history_table::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::PaymentHistoryTable.def()
        }
    }
    impl Related<super::taking_record_table::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::TakingRecordTable.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
